package automaticMalwareDetection;

public class FeatureRanking {
	public static void main(String[] args) {
		// {benign, malware}
		double[] sampleSize = {1000.0, 1000.0};
		double[][] features = {{754.0, 125.0}, {42.0, 742.0}};

		for (double[]feature : features) {
			System.out.println("-----------------------------------------");
			System.out.println("Rank of feature = " + calcRank(feature, sampleSize));
			System.out.println("-----------------------------------------");
		}
	}

	/**
	 * Calculates the rank of a single feature
	 * @param feature The feature in the format [numOfOccBenign, numOfOccMalware]
	 * @param sampleSize The sample size of applications analysed [numOfBenignApps, numOfMalwareApps]
	 * @return The rank of the feature
	 */
	public static double calcRank(double[] feature, double[] sampleSize) {
		double occurIfBenign = feature[0];
		double occurIfMalware = feature[1];

		double totalOccurred = occurIfBenign + occurIfMalware;

		double totalSampleSize = sampleSize[0] + sampleSize[1];

		double totalNotOccur = totalSampleSize - totalOccurred;

		double Ri_0 = totalNotOccur / totalSampleSize;
		System.out.println("P(Ri=0) = " + Ri_0);

		double Ri_1= totalOccurred / totalSampleSize;
		System.out.println("P(Ri=1) = " + Ri_1);

		double CB_0 = (sampleSize[0] - occurIfBenign) / totalNotOccur;
		System.out.println("P(C=B | Ri=0) = " + CB_0);

		double CB_1 = occurIfBenign / totalOccurred;
		System.out.println("P(C=B | Ri=1) = " + CB_1);

		double CM_0 = (sampleSize[1] - occurIfMalware) / totalNotOccur;
		System.out.println("P(C=M | Ri=0) = " + CM_0);

		double CM_1 = occurIfMalware / totalOccurred;
		System.out.println("P(C=M | Ri=1) = " + CM_1);

		double CB = sampleSize[0] / totalSampleSize;
		System.out.println("P(C=B) = " + CB);

		double CM = sampleSize[1] / totalSampleSize;
		System.out.println("P(C=M) = " + CM);

		System.out.println();

		double rankOfNotOcc = rankingOfOcc(rankingOfClass(CB, CB_0), rankingOfClass(CM, CM_0), Ri_0);
		System.out.println("rank of not occurring = " + rankOfNotOcc);

		double rankOfOcc = rankingOfOcc(rankingOfClass(CB, CB_1), rankingOfClass(CM, CM_1), Ri_1);
		System.out.println("rank of occurring = " + rankOfNotOcc);

		System.out.println();

		double mutualInformation = rankOfOcc + rankOfNotOcc;

		return mutualInformation;
	}

	/**
	 * Calculates the ranking of a feature based of if it occurs or not.
	 * An example is if you are calculating the rank of it occurring P(R=1) the rank of 
	 * benign and malware are required to have been calculated using the probability of it 
	 * occurring as well and vice versa for the probability of it not occurring P(R=0)
	 * @param rankOfBenign The rank if the feature is benign based of if it occurs or not
	 * @param rankOfMalware The rank if the feature is malware based of if it occurs or not
	 * @param totalProbOcc The total probability of the feature occurring
	 * @return The rank of the feature 
	 */
	public static double rankingOfOcc(double rankOfBenign, double rankOfMalware, double totalProbOcc) {
		return totalProbOcc * (rankOfBenign + rankOfMalware);
	}

	/**
	 * Calculates the rank of a feature depending on the class and the occurrence
	 * @param probOfClass The probability of what class it is
	 * @param probOfOcc The probability of the either the class occurring or not 
	 * @return The rank of the feature depending on the class and occurrence
	 */
	public static double rankingOfClass(double probOfClass, double probOfOcc) {
		return probOfOcc * log2((probOfOcc / probOfClass));
	}

	/**
	 * Calculates the log base 2 of a certain number
	 * @param x The number to be used
	 * @return The log base 2 of the number
	 */
	public static double log2(double x) {
		return Math.log(x) / Math.log(2);
	}
}
